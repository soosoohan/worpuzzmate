<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>worpuzzmate</title>
<style>
 
/* 전체 배경과 기본 텍스트 */
body {
  font-family: 'Noto Sans KR', sans-serif;
  background-color: #f0f8f7; 
  margin: 0 auto;
  padding: 20px;
  color: #333;
  text-align: center;
}


/* 제목 */
h1 {
  font-size: 28px;
  text-align: center;
  margin-bottom: 10px;
  font-weight: bold;
  color: #064d4d;
}

/* 설명문 */
p {
    margin: 0 0 10px;
  font-size: 14px;
  margin-bottom: 20px;
  color: #064d4d;
    text-align: center;
}
  .name-input {
    display: flex;
    justify-content: space-between;
    gap: 20px;
    width: 100%;
    max-width: 800px;
    margin-bottom: 15px;
  }
  .name-input div {
    display: flex;
    flex-direction: column;
    flex: 1;
  }
  .name-input input {
    font-size: 20px;
    padding: 8px;
    margin-top: 5px;
    border: 1px solid #ccc;
    border-radius: 4px;
  }

  .container {
    display: flex;
    align-items: flex-start;
    gap: 20px;
    margin-bottom: 10px;
    flex-wrap: wrap;
    justify-content: center;
  }
  #player1Score, #player2Score {
    width: 160px;
    min-height: 300px;
    padding: 10px;
    font-size: 20px;
    font-weight: bold;
    border: 2px solid #333;
    box-sizing: border-box;
  }

#player1Score { background-color:  #b7d5f2; }
  #player2Score { background-color: #f6c28b; }
  #game {
    display: grid;
    grid-template-columns: repeat(10, 50px);
    grid-gap: 5px;
    padding: 10px;
    border: 2px solid #333;
    background-color: #eee;
  }

.cell {
  width: 50px;
  height: 50px;
  background-color: #ddd;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 24px;        /* ✅ 글씨 조금 키움 */
  cursor: pointer;
  user-select: none;
  border: 1px solid #999;
}

  .revealed { background-color: #fff; }
  .word-owned-player1 { background-color: #b7d5f2; }
  .word-owned-player2 { background-color: #f6c28b; }
  
#currentTurn {
    font-size: 20px;
    margin: 10px;
    color: #056762;
  }
  .player-name-row {
    display: flex;
    align-items: center;
    gap: 20px;
    margin-bottom: 15px;
  }
  .player-input {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
  }
  .player-input label {
    font-size: 20px;
    color: #333;
  }
  .player-input input {
    font-size: 20px;
    padding: 8px;
    border: 1px solid #aaa;
    border-radius: 4px;
    width: 150px;
    text-align: center;
  }
  .guess-section {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    align-items: center;
  }
  .guess-section input {
    font-size: 20px;
    padding: 8px;
    border: 1px solid #aaa;
    border-radius: 4px;
    width: 200px;
  }
  .game-area {
    display: flex;
    align-items: flex-start;
    gap: 20px;
    margin:  auto;
  }
  .controls {
    display: flex;
    gap: 10px;
  }
  #wrongGuesses {
    margin-bottom: 15px;
    font-size: 20px;
    color: #056762;
  }


.game-button {
  font-size: 18px;
  background-color: #c8f4ee; 
  padding: 10px 22px;
  margin: 8px;
  color: #064d4d;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: background 0.3s ease, transform 0.2s ease;
  box-shadow: 2px 2px 4px rgba(0,0,0,0.2);
}

.game-button:hover {
  background-color: #1d9e95; 
  transform: scale(1.05);
}


/* 격자 */
.grid {
  display: grid;
  grid-template-columns: repeat(8, 40px);
  grid-template-rows: repeat(8, 40px);
  gap: 4px;
  justify-content: center;
  margin: 20px auto;
}

.grid-cell {
  background-color: #fcf8ef; /* 연베이지 */
  border: 1px solid #ccc;
  font-size: 18px;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #333;
  border-radius: 4px;
}

/* 클로버, 데이지 등 아이템 이모지 */
.grid-cell .emoji {
  font-size: 18px;
}

/* 점수/정보 컨테이너 */
.info-section {
  display: flex;
  justify-content: space-between;
  max-width: 700px;
  margin: 0 auto 20px auto;
  flex-wrap: wrap;
}

/* game-container 정렬 추가 */
.game-container {
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* 이름 입력칸 & 버튼을 가운데로 */
.player-name-row {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 20px;
  margin-bottom: 15px;
}

/* 추측입력칸도 가운데 */
.guess-section {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 10px;
  margin-bottom: 15px;
}

/* 격자 바닥색을 body 배경색과 동일하게 */
.grid-cell {
  background-color: #fffaf5; /* 기존 #fcf8ef에서 변경 */
  border: 1px solid #ccc;
  font-size: 18px;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #333;
  border-radius: 4px;
}

</style>




</head>
<body>

<h1 id="game-title">게임 제목</h1>
<p id="game-desc" class="rule">게임 설명</p>


<div class="game-container">

  <div class="player-name-row">
    <div class="player-input">
      <input type="text" id="player1Name" placeholder="first player" />
    </div>
    <div class="player-input">
      <input type="text" id="player2Name" placeholder="second player" />
    </div>
    <button id="startBtn" class="game-button">게임 시작</button>
  </div>

  <div id="currentTurn"></div>

  <div class="guess-section">
    <input type="text" id="guessInput" placeholder="your guess" />
    <button id="guessBtn" class="game-button">SUBMIT</button>
  </div>

  <div id="wrongGuesses" style="display: none;">
    <strong>Invalid words:</strong> <span id="wrongList"></span>
  </div>

  <div class="game-area">
    <div id="player1Score"></div>
    <div id="game"></div>
    <div id="player2Score"></div>
  </div>

  <div class="controls">
    <button id="retryBtn" class="game-button">RETRY</button>
    <button onclick="location.href='index.html'" class="game-button">HOME</button>
  </div>
</div>

<script>
window.onload = () => {
  // 1. URL 파라미터에서 워드풀 파일명 추출
  const urlParams = new URLSearchParams(window.location.search);
  const poolFile = urlParams.get('pool');
  if (!poolFile) {
    document.body.innerHTML = '<p>❌ 워드풀 파일이 지정되지 않았습니다.</p>';
    return;
  }


// 2.fetch word pool JSON
  fetch('wordpools/' + poolFile)
    .then(res => res.json())
    .then(data => {
      document.getElementById('game-title').textContent = data.title || '게임 제목';
      document.getElementById('game-desc').textContent = data.description || '게임 설명';




      // 3. 워드 배열(words) 구성
      words = [];
      for (let length in data.words) {
        const count = data.wordCount[length] || 0;
        const selected = getRandomSample(data.words[length], count);
        words.push(...selected);
      }

      // 4. 게임 초기화 실행
      init();
    })
    .catch(err => {
      document.body.innerHTML = '<p>❌ 워드풀 로딩 중 오류 발생: ' + err.message + '</p>';
    });

  // 5. 전역 변수 선언
  const gridSize = 10;
  const totalCells = gridSize * gridSize;
  let board, revealed, wordMap, foundWords, currentPlayer, foundBy, words, usedIndexes;
  let clovers = new Set(), daisies = new Set(), resultShown = false;
  let player1 = "플레이어1", player2 = "플레이어2", currentPlayerName = "", wrongGuesses = [];

  // 6. DOM 요소 불러오기
  const gameEl = document.getElementById('game');
  const player1ScoreEl = document.getElementById('player1Score');
  const player2ScoreEl = document.getElementById('player2Score');
  const retryBtn = document.getElementById('retryBtn');
  const startBtn = document.getElementById('startBtn');
  const currentTurnEl = document.getElementById('currentTurn');
  const guessInput = document.getElementById('guessInput');
  const guessBtn = document.getElementById('guessBtn');
  const wrongListEl = document.getElementById('wrongList');
  const wrongGuessesEl = document.getElementById('wrongGuesses');


    
  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  function getRandomSample(arr, count) {
    if (count >= arr.length) return [...arr];
    const shuffled = [...arr];
    shuffle(shuffled);
    return shuffled.slice(0, count);
  }

  // fetch word pool JSON
  fetch('wordpools/' + poolFile)
    .then(res => res.json())
    .then(data => {
      document.getElementById('game-title').textContent = data.title || '게임 제목';
      document.getElementById('game-desc').textContent = data.description || '게임 설명';

      words = [];
      for (let length in data.words) {
        const count = data.wordCount[length] || 0;
        const selected = getRandomSample(data.words[length], count);
        words.push(...selected);
      }

      init();
    })
    .catch(err => {
      document.body.innerHTML = '<p>❌ 워드풀 로딩 중 오류 발생: ' + err.message + '</p>';
    });



  function init() {
    board = Array(totalCells).fill(null);
    revealed = Array(totalCells).fill(false);
    wordMap = {};
    foundWords = new Set();
    foundBy = { player1: [], player2: [] };
    currentPlayer = 'player1';
    usedIndexes = new Set();
    wrongGuesses = [];
    wrongListEl.textContent = "";
    wrongGuessesEl.style.display = 'none';
    resultShown = false;

    player1 = document.getElementById('player1Name').value.trim() || "플레이어1";
    player2 = document.getElementById('player2Name').value.trim() || "플레이어2";

    gameEl.innerHTML = '';
    for (let i = 0; i < totalCells; i++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.onclick = () => { if (!resultShown) handleClick(i); };
      gameEl.appendChild(cell);
    }

    shuffle(words);
    words.forEach(w => placeWord(w));
    placeDaisies(2);
    placeClovers(6);
    fillEmptyCells();
    updateScore();
    updateTurnDisplay();
  }

  function canPlaceWord(word, x, y, dx, dy) {
    for (let i = 0; i < word.length; i++) {
      let nx = x + dx * i, ny = y + dy * i, idx = ny * gridSize + nx;
      if (nx < 0 || ny < 0 || nx >= gridSize || ny >= gridSize || (board[idx] && board[idx] !== word[i]) || usedIndexes.has(idx)) return false;
    }
    return true;
  }

  function placeWord(word) {
    for (let attempt = 0; attempt < 100; attempt++) {
      let dir = getRandomDirection(), x = Math.floor(Math.random() * gridSize), y = Math.floor(Math.random() * gridSize);
      if (canPlaceWord(word, x, y, dir.x, dir.y)) {
        let positions = [];
        for (let i = 0; i < word.length; i++) {
          let nx = x + dir.x * i, ny = y + dir.y * i, idx = ny * gridSize + nx;
          board[idx] = word[i];
          usedIndexes.add(idx);
          positions.push(idx);
        }
        wordMap[word] = positions;
        return true;
      }
    }
    return false;
  }


function placeDaisies(count) {
  daisies.clear();
  let attempts = 0;
  while (daisies.size < count && attempts < 1000) {
    const idx = Math.floor(Math.random() * totalCells);
    const tooCloseToOtherDaisy = isAdjacentToAnyItem(idx, daisies);
    if (
      !usedIndexes.has(idx) &&
      !clovers.has(idx) &&
      !daisies.has(idx) &&
      !tooCloseToOtherDaisy
    ) {
      daisies.add(idx);
    }
    attempts++;
  }
}


function isAdjacentToAnyItem(idx, itemSet) {
  const x = idx % gridSize;
  const y = Math.floor(idx / gridSize);
  for (let dx = -1; dx <= 1; dx++) {
    for (let dy = -1; dy <= 1; dy++) {
      if (dx === 0 && dy === 0) continue;
      const nx = x + dx;
      const ny = y + dy;
      const nIdx = ny * gridSize + nx;
      if (
        nx >= 0 && nx < gridSize &&
        ny >= 0 && ny < gridSize &&
        itemSet.has(nIdx)
      ) {
        return true;
      }
    }
  }
  return false;
}



function placeClovers(count) {
  clovers.clear();
  let attempts = 0;
  while (clovers.size < count && attempts < 1000) {
    const idx = Math.floor(Math.random() * totalCells);
    const isTooCloseToDaisy = isAdjacentToAnyItem(idx, daisies);
    const isTooCloseToOtherClover = isAdjacentToAnyItem(idx, clovers);
    if (
      !usedIndexes.has(idx) &&
      !clovers.has(idx) &&
      !daisies.has(idx) &&
      !isTooCloseToDaisy &&
      !isTooCloseToOtherClover
    ) {
      clovers.add(idx);
    }
    attempts++;
  }
}



  function fillEmptyCells() {
    const filler = 'QWERTYUIOPASDFGHJKLZXCVBNM'.split('');
    
    shuffle(filler);
    let iFiller = 0;
    for (let i = 0; i < totalCells; i++) {
      if (!board[i] && !clovers.has(i) && !daisies.has(i)) {
        board[i] = filler[iFiller++ % filler.length];
      }
    }
  }

  function updateScore() {
    player1ScoreEl.innerHTML = `<strong>${player1}</strong><br><br>` + (foundBy.player1.length > 0 ? foundBy.player1.map(word => `✓ ${word}`).join("<br>") : "");
    player2ScoreEl.innerHTML = `<strong>${player2}</strong><br><br>` + (foundBy.player2.length > 0 ? foundBy.player2.map(word => `✓ ${word}`).join("<br>") : "");
  }

  function updateTurnDisplay() {
    currentPlayerName = currentPlayer === 'player1' ? player1 : player2;
    currentTurnEl.textContent = `${currentPlayerName}님의 차례입니다`;
  }

  function reveal(index) {
    if (revealed[index]) return;
    revealed[index] = true;
    const cell = gameEl.children[index];

    if (clovers.has(index)) {
      cell.textContent = '🍀';
      cell.classList.add('revealed');
      cell.title = '클로버: 십자 모양으로 확산!';
      const dx = [0, 0, -1, 1, 0];
      const dy = [-1, 1, 0, 0, 0];
      for (let d = 0; d < dx.length; d++) {
        const nx = index % gridSize + dx[d];
        const ny = Math.floor(index / gridSize) + dy[d];
        const nIdx = ny * gridSize + nx;
        if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && !revealed[nIdx]) reveal(nIdx);
      }
    } else if (daisies.has(index)) {
      cell.textContent = '🌼';
      cell.classList.add('revealed');
      cell.title = '데이지: 주변 모든 칸이 열립니다!';
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          const nx = index % gridSize + dx;
          const ny = Math.floor(index / gridSize) + dy;
          const nIdx = ny * gridSize + nx;
          if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && !revealed[nIdx]) reveal(nIdx);
        }
      }
    } else {
      cell.textContent = board[index];
      cell.classList.add('revealed');
    }
  }


  function checkWords() {
    for (let word of words) {
      if (foundWords.has(word)) continue;
      const pos = wordMap[word];
      if (pos.every(i => revealed[i])) {
        foundWords.add(word);
        foundBy[currentPlayer].push(word);
        pos.forEach(i => gameEl.children[i].classList.add(currentPlayer === 'player1' ? 'word-owned-player1' : 'word-owned-player2'));
        updateScore();
      }
    }
    if (foundWords.size === words.length && !resultShown) {
      resultShown = true;
      let p1 = foundBy.player1.length, p2 = foundBy.player2.length;
      if (p1 > p2) {
        
        currentTurnEl.innerHTML = ` GAME OVER`;
        currentTurnEl.style.background = '';
      } else if (p2 > p1) {
        player2ScoreEl.innerHTML += "";
        player1ScoreEl.innerHTML += "";
        currentTurnEl.innerHTML = `GAME OVER `;
        currentTurnEl.style.background = '';
      } else {
        currentTurnEl.innerHTML = ` GAME OVER`;
        currentTurnEl.style.background = '';
      }
    }
  }

  function switchTurn(extraTurnItemFound) {
    if (!extraTurnItemFound) currentPlayer = currentPlayer === 'player1' ? 'player2' : 'player1';
    updateTurnDisplay();
  }

  function handleClick(index) {
    if (revealed[index] || resultShown) return;
    const isClover = clovers.has(index);
    const isDaisy = daisies.has(index);
    const gotExtraTurn = isClover || isDaisy;

    reveal(index);
    checkWords();
    if (!resultShown) switchTurn(gotExtraTurn);
  }



  function handleGuess() {
    const guess = guessInput.value.trim();
    guessInput.value = "";

    if (!guess || foundWords.has(guess)) return;

    if (words.includes(guess)) {
      const pos = wordMap[guess];
      pos.forEach(i => {
        if (!revealed[i]) reveal(i);
      });
      foundWords.add(guess);
      foundBy[currentPlayer].push(guess);
      pos.forEach(i => gameEl.children[i].classList.add(currentPlayer === 'player1' ? 'word-owned-player1' : 'word-owned-player2'));
      updateScore();
      checkWords();
    } else {
      if (!wrongGuesses.includes(guess)) {
        wrongGuesses.push(guess);
        wrongListEl.textContent = wrongGuesses.join(", ");
        wrongGuessesEl.style.display = 'block';
      }
      switchTurn(false);
    }
  }



  startBtn.onclick = init;
  retryBtn.onclick = init;
  guessBtn.onclick = handleGuess;
  guessInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleGuess();
  });
};
</script>

</body>
</html> 
