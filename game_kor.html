<!DOCTYPE html>

<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ì›Œí¼ì¦ˆë©”ì´íŠ¸</title>
  <style>
    body {
      font-family: 'Noto Sans KR', sans-serif;
      background-color: #f0f8f7;
      margin: 0;
      padding: 20px;
      color: #333;
      text-align: center;
    }
    h1 {
      font-size: 28px;
      margin-bottom: 10px;
      font-weight: bold;
      color: #064d4d;
    }
    p {
      font-size: 14px;
      margin-bottom: 20px;
      color: #064d4d;
    }
    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .player-name-row {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 15px;
    }
    .player-input input {
      font-size: 20px;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 150px;
      text-align: center;
    }
    .start-section {
      margin-bottom: 15px;
    }
    .guess-section {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 15px;
    }
    .guess-section input {
      font-size: 20px;
      padding: 8px;
      border: 1px solid #aaa;
      border-radius: 4px;
      width: 200px;
    }
    .game-area {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
    }
    .game-button {
      font-size: 18px;
      background-color: #c8f4ee;
      padding: 10px 22px;
      margin: 8px;
      color: #064d4d;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }
    .game-button:hover {
      background-color: #1d9e95;
      transform: scale(1.05);
    }
    .cell {
      width: 50px;
      height: 50px;
      background-color: #ddd;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 24px;
      cursor: pointer;
      user-select: none;
      border: 1px solid #999;
    }
    .revealed { background-color: #fff; }
    .word-owned-player1 { background-color: #b7d5f2; }
    .word-owned-player2 { background-color: #f6c28b; }
    #player1Score, #player2Score {
      width: 160px;
      min-height: 300px;
      padding: 10px;
      font-size: 20px;
      font-weight: bold;
      border: 2px solid #333;
    }
    #player1Score { background-color:  #b7d5f2; }
    #player2Score { background-color: #f6c28b; }
    #currentTurn {
      font-size: 20px;
      margin: 10px;
      color: #056762;
    }
    #game {
      display: grid;
      grid-template-columns: repeat(10, 50px);
      grid-gap: 5px;
      padding: 10px;
      border: 2px solid #333;
      background-color: #eee;
    }
    .hidden {
      display: none;
    }
  </style>
</head>
<body>

<h1 id="game-title">ê²Œì„ ì œëª©</h1>
<p id="game-desc">ê²Œì„ ì„¤ëª…</p>

<div class="game-container">

  <div class="player-name-row">
    <div class="player-input"><input type="text" id="player1Name" placeholder="ë¨¼ì € í•˜ì‹¤ ë¶„" /></div>
    <div class="player-input"><input type="text" id="player2Name" placeholder="ë‚˜ì¤‘ì— í•˜ì‹¤ ë¶„" /></div>
  </div>

  <div class="start-section">
    <button id="startBtn" class="game-button">ê²Œì„ ì‹œì‘</button>
  </div>

  <div id="gameSection" class="hidden">
    <div id="currentTurn"></div>


<div class="guess-section">
  <input type="text" id="guessInput" placeholder="ì¶”ì¸¡í•œ ë‹¨ì–´" />
  <button id="guessBtn" class="game-button">ì œì¶œ</button>
</div>

<div id="wrongGuesses" style="display: none;">
  <strong>ì—†ëŠ” ë‹¨ì–´:</strong> <span id="wrongList"></span>
</div>

<div class="game-area">
  <div id="player1Score"></div>
  <div id="game"></div>
  <div id="player2Score"></div>
</div>

<div class="controls">
  <button id="retryBtn" class="game-button"ë‹¤ì‹œ í•˜ê¸°</button>
  <button onclick="location.href='index.html'" class="game-button">ì´ˆê¸° í™”ë©´</button>
</div>

  </div>

</div>

<script>
window.onload = () => {
  const urlParams = new URLSearchParams(window.location.search);
  const poolFile = urlParams.get('pool');
  if (!poolFile) {
    document.body.innerHTML = '<p>âŒ ì›Œë“œí’€ íŒŒì¼ì´ ì§€ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.</p>';
    return;
  }

  fetch('wordpools/' + poolFile + '.json')
    .then(res => res.json())
    .then(data => {
      document.getElementById('game-title').textContent = data.title || 'ê²Œì„ ì œëª©';
      document.getElementById('game-desc').textContent = data.description || 'ê²Œì„ ì„¤ëª…';
      words = [];
      for (let length in data.words) {
        const count = data.wordCount[length] || 0;
        words.push(...getRandomSample(data.words[length], count));
      }
      console.log('ì´ ë‹¨ì–´ ìˆ˜:', words.length);
      console.log('ë‹¨ì–´ ëª©ë¡:', words);
    })
    .catch(err => {
      document.body.innerHTML = '<p>âŒ ì›Œë“œí’€ ë¡œë”© ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + err.message + '</p>';
    });

  const gridSize = 12;
  const totalCells = gridSize * gridSize;
  let board, revealed, wordMap, foundWords, currentPlayer, foundBy, words, usedIndexes;
  let clovers = new Set(), daisies = new Set(), resultShown = false, gameStarted = false;
  let player1 = "í”Œë ˆì´ì–´1", player2 = "í”Œë ˆì´ì–´2", currentPlayerName = "", wrongGuesses = [];

  const gameEl = document.getElementById('game');
  const player1ScoreEl = document.getElementById('player1Score');
  const player2ScoreEl = document.getElementById('player2Score');
  const retryBtn = document.getElementById('retryBtn');
  const startBtn = document.getElementById('startBtn');
  const gameSection = document.getElementById('gameSection');
  const currentTurnEl = document.getElementById('currentTurn');
  const guessInput = document.getElementById('guessInput');
  const guessBtn = document.getElementById('guessBtn');
  const wrongListEl = document.getElementById('wrongList');
  const wrongGuessesEl = document.getElementById('wrongGuesses');

  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  function getRandomSample(arr, count) {
    if (count >= arr.length) return [...arr];
    const shuffled = [...arr];
    shuffle(shuffled);
    return shuffled.slice(0, count);
  }

  function startGame() {
    player1 = document.getElementById('player1Name').value.trim() || "í”Œë ˆì´ì–´1";
    player2 = document.getElementById('player2Name').value.trim() || "í”Œë ˆì´ì–´2";
    
    gameSection.classList.remove('hidden');
    startBtn.style.display = 'none';
    gameStarted = true;
    
    init();
  }

  function init() {
    board = Array(totalCells).fill(null);
    revealed = Array(totalCells).fill(false);
    wordMap = {};
    foundWords = new Set();
    foundBy = { player1: [], player2: [] };
    currentPlayer = 'player1';
    usedIndexes = new Set();
    clovers.clear();
    daisies.clear();
    wrongGuesses = [];
    wrongListEl.textContent = "";
    wrongGuessesEl.style.display = 'none';
    resultShown = false;

    gameEl.innerHTML = '';
    for (let i = 0; i < totalCells; i++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.onclick = () => { if (!resultShown) handleClick(i); };
      gameEl.appendChild(cell);
    }

    // ë‹¨ì–´ ë°°ì¹˜ (ì¬ì‹œë„ ë¡œì§ ê°•í™”)
    let placedWords = [];
    shuffle(words);
    
    for (let word of words) {
      let placed = false;
      for (let attempt = 0; attempt < 500; attempt++) {
        if (placeWord(word)) {
          placedWords.push(word);
          placed = true;
          break;
        }
      }
      if (!placed) {
        console.log('ë°°ì¹˜ ì‹¤íŒ¨í•œ ë‹¨ì–´:', word);
      }
    }
    
    console.log('ì‹¤ì œ ë°°ì¹˜ëœ ë‹¨ì–´ ìˆ˜:', placedWords.length);
    console.log('ë°°ì¹˜ëœ ë‹¨ì–´ë“¤:', placedWords);
    
    // í´ë¡œë²„/ë°ì´ì§€ ë°°ì¹˜ (ë‹¨ì–´ ì˜ì—­ í”¼í•˜ê¸°)
    placeDaisies(2);
    placeClovers(5);
    fillEmptyCells();
    updateScore();
    updateTurnDisplay();
    
    // ê²Œì„ ì¢…ë£Œ ì¡°ê±´ í™•ì¸
    checkGameEnd();
  }

  function canPlaceWord(word, x, y, dx, dy) {
    for (let i = 0; i < word.length; i++) {
      let nx = x + dx * i, ny = y + dy * i;
      if (nx < 0 || ny < 0 || nx >= gridSize || ny >= gridSize) return false;
      
      let idx = ny * gridSize + nx;
      if (board[idx] && board[idx] !== word[i]) return false;
      if (usedIndexes.has(idx)) return false;
    }
    return true;
  }

  function placeWord(word) {
    const directions = [
      { x: 1, y: 0 },   // ê°€ë¡œ
      { x: 0, y: 1 },   // ì„¸ë¡œ
      { x: 1, y: 1 }   // ëŒ€ê°ì„  
    ];

  shuffle(directions);

    
    for (let dir of directions) {
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          if (canPlaceWord(word, x, y, dir.x, dir.y)) {
            let positions = [];
            for (let i = 0; i < word.length; i++) {
              let nx = x + dir.x * i, ny = y + dir.y * i, idx = ny * gridSize + nx;
              board[idx] = word[i];
              usedIndexes.add(idx);
              positions.push(idx);
            }
            wordMap[word] = positions;
            return true;
          }
        }
      }
    }
    return false;
  }

  function placeClovers(count) {
    let placed = 0;
    let attempts = 0;
    while (placed < count && attempts < 1000) {
      const idx = Math.floor(Math.random() * totalCells);
      if (!usedIndexes.has(idx) && !clovers.has(idx) && !daisies.has(idx)) {
        // ì£¼ë³€ì— ë‹¨ì–´ê°€ ì—†ê³  ë‹¤ë¥¸ íŠ¹ìˆ˜ ì•„ì´í…œê³¼ ê±°ë¦¬ê°€ ìˆëŠ”ì§€ í™•ì¸
        if (isSafeForSpecial(idx) && !isNearSpecialItem(idx)) {
          clovers.add(idx);
          placed++;
        }
      }
      attempts++;
    }
    console.log('ë°°ì¹˜ëœ í´ë¡œë²„ ìˆ˜:', clovers.size);
  }

  function placeDaisies(count) {
    let placed = 0;
    let attempts = 0;
    while (placed < count && attempts < 1000) {
      const idx = Math.floor(Math.random() * totalCells);
      if (!usedIndexes.has(idx) && !clovers.has(idx) && !daisies.has(idx)) {
        // ì£¼ë³€ì— ë‹¨ì–´ê°€ ì—†ê³  ë‹¤ë¥¸ íŠ¹ìˆ˜ ì•„ì´í…œê³¼ ê±°ë¦¬ê°€ ìˆëŠ”ì§€ í™•ì¸
        if (isSafeForSpecial(idx) && !isNearSpecialItem(idx)) {
          daisies.add(idx);
          placed++;
        }
      }
      attempts++;
    }
    console.log('ë°°ì¹˜ëœ ë°ì´ì§€ ìˆ˜:', daisies.size);
  }

  function isNearSpecialItem(idx) {
    const x = idx % gridSize;
    const y = Math.floor(idx / gridSize);
    
    // ì£¼ë³€ 2ì¹¸ ë°˜ê²½ ë‚´ì— ë‹¤ë¥¸ íŠ¹ìˆ˜ ì•„ì´í…œì´ ìˆëŠ”ì§€ í™•ì¸
    for (let dy = -2; dy <= 2; dy++) {
      for (let dx = -2; dx <= 2; dx++) {
        if (dx === 0 && dy === 0) continue;
        const nx = x + dx;
        const ny = y + dy;
        if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
          const nIdx = ny * gridSize + nx;
          if (clovers.has(nIdx) || daisies.has(nIdx)) {
            return true;
          }
        }
      }
    }
    return false;
  }

  function isSafeForSpecial(idx) {
    const x = idx % gridSize;
    const y = Math.floor(idx / gridSize);
    
    // ì£¼ë³€ 8ì¹¸ í™•ì¸
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        const nx = x + dx;
        const ny = y + dy;
        if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
          const nIdx = ny * gridSize + nx;
          if (usedIndexes.has(nIdx)) return false;
        }
      }
    }
    return true;
  }

  function fillEmptyCells() {
    const filler = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
    shuffle(filler);
    let i = 0;
    for (let j = 0; j < totalCells; j++) {
      if (!board[j] && !clovers.has(j) && !daisies.has(j)) {
        board[j] = filler[i++ % filler.length];
      }
    }
  }

  function reveal(index) {
    if (revealed[index]) return;
    revealed[index] = true;
    const cell = gameEl.children[index];
    
    if (clovers.has(index)) {
      cell.textContent = 'ğŸ€';
      // ìƒí•˜ì¢Œìš° 4ì¹¸ ì—´ê¸°
      const directions = [-gridSize, gridSize, -1, 1];
      for (let d of directions) {
        const newIdx = index + d;
        if (newIdx >= 0 && newIdx < totalCells) {
          // ì¢Œìš° ì´ë™ ì‹œ ê°™ì€ í–‰ì— ìˆëŠ”ì§€ í™•ì¸
          if (d === -1 || d === 1) {
            if (Math.floor(index / gridSize) === Math.floor(newIdx / gridSize)) {
              reveal(newIdx);
            }
          } else {
            reveal(newIdx);
          }
        }
      }
    } else if (daisies.has(index)) {
      cell.textContent = 'ğŸŒ¼';
      // ì£¼ë³€ 8ì¹¸ ëª¨ë‘ ì—´ê¸°
      const x = index % gridSize;
      const y = Math.floor(index / gridSize);
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
            const nIdx = ny * gridSize + nx;
            if (!revealed[nIdx]) reveal(nIdx);
          }
        }
      }
    } else {
      cell.textContent = board[index];
    }
    cell.classList.add('revealed');
  }

  function updateScore() {
    player1ScoreEl.innerHTML = `<strong>${player1}</strong><br><br>` + foundBy.player1.map(w => `âœ“ ${w}`).join("<br>");
    player2ScoreEl.innerHTML = `<strong>${player2}</strong><br><br>` + foundBy.player2.map(w => `âœ“ ${w}`).join("<br>");
  }

  function updateTurnDisplay() {
    if (!gameStarted) return;
    currentPlayerName = currentPlayer === 'player1' ? player1 : player2;
    currentTurnEl.textContent = `${currentPlayerName}ë‹˜ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤`;
  }

  function switchTurn(extra) {
    if (!extra) {
      currentPlayer = currentPlayer === 'player1' ? 'player2' : 'player1';
    }
    updateTurnDisplay();
  }

  function handleClick(index) {
    if (revealed[index] || resultShown || !gameStarted) return;
    
    const extra = clovers.has(index) || daisies.has(index);
    reveal(index);
    checkWords();
    checkGameEnd();
    
    if (!resultShown) {
      switchTurn(extra);
    }
  }

  function checkWords() {
    for (let word of Object.keys(wordMap)) {
      if (foundWords.has(word)) continue;
      const pos = wordMap[word];
      if (pos.every(i => revealed[i])) {
        foundWords.add(word);
        foundBy[currentPlayer].push(word);
        pos.forEach(i => {
          const cell = gameEl.children[i];
          cell.classList.add(currentPlayer === 'player1' ? 'word-owned-player1' : 'word-owned-player2');
        });
        updateScore();
      }
    }
  }

  function checkGameEnd() {
    const totalWords = Object.keys(wordMap).length;
    if (foundWords.size >= totalWords && totalWords > 0) {
      resultShown = true;
      const p1Count = foundBy.player1.length;
      const p2Count = foundBy.player2.length;
      
      let winner;
      if (p1Count > p2Count) winner = player1;
      else if (p2Count > p1Count) winner = player2;
      else winner = "ë¬´ìŠ¹ë¶€";
      
      setTimeout(() => {
        alert(`ê²Œì„ ì¢…ë£Œ!\n${winner === "ë¬´ìŠ¹ë¶€" ? "ë¬´ìŠ¹ë¶€ì…ë‹ˆë‹¤!" : winner + "ë‹˜ì´ ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤!"}\n\n${player1}: ${p1Count}ê°œ\n${player2}: ${p2Count}ê°œ`);
      }, 500);
    }
  }

  function handleGuess() {
    if (!gameStarted) return;
    
    const guess = guessInput.value.trim().toUpperCase(); // ëŒ€ë¬¸ìë¡œ ë³€í™˜
    guessInput.value = "";
    if (!guess || foundWords.has(guess)) return;
    
    if (wordMap[guess]) {
      const pos = wordMap[guess];
      pos.forEach(i => {
        if (!revealed[i]) reveal(i);
      });
      foundWords.add(guess);
      foundBy[currentPlayer].push(guess);
      pos.forEach(i => {
        const cell = gameEl.children[i];
        cell.classList.add(currentPlayer === 'player1' ? 'word-owned-player1' : 'word-owned-player2');
      });
      updateScore();
      checkGameEnd();
    } else {
      if (!wrongGuesses.includes(guess)) {
        wrongGuesses.push(guess);
        wrongListEl.textContent = wrongGuesses.join(", ");
        wrongGuessesEl.style.display = 'block';
      }
    }
    
    if (!resultShown) {
      switchTurn(false);
    }
  }

  function retry() {
    if (!gameStarted) return;
    init();
  }

  startBtn.onclick = startGame;
  retryBtn.onclick = retry;
  guessBtn.onclick = handleGuess;
  guessInput.addEventListener('keypress', e => {
    if (e.key === 'Enter') handleGuess();
  });
};
</script>

</body>
</html><!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ì›Œí¼ì¦ˆë©”ì´íŠ¸</title>
  <style>
    body {
      font-family: 'Noto Sans KR', sans-serif;
      background-color: #f0f8f7;
      margin: 0;
      padding: 20px;
      color: #333;
      text-align: center;
    }
    h1 {
      font-size: 28px;
      margin-bottom: 10px;
      font-weight: bold;
      color: #064d4d;
    }
    p {
      font-size: 14px;
      margin-bottom: 20px;
      color: #064d4d;
    }
    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .player-name-row {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 15px;
    }
    .player-input input {
      font-size: 20px;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 150px;
      text-align: center;
    }
    .start-section {
      margin-bottom: 15px;
    }
    .guess-section {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 15px;
    }
    .guess-section input {
      font-size: 20px;
      padding: 8px;
      border: 1px solid #aaa;
      border-radius: 4px;
      width: 200px;
    }
    .game-area {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
    }
    .game-button {
      font-size: 18px;
      background-color: #c8f4ee;
      padding: 10px 22px;
      margin: 8px;
      color: #064d4d;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }
    .game-button:hover {
      background-color: #1d9e95;
      transform: scale(1.05);
    }
    .cell {
      width: 50px;
      height: 50px;
      background-color: #ddd;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 24px;
      cursor: pointer;
      user-select: none;
      border: 1px solid #999;
    }
    .revealed { background-color: #fff; }
    .word-owned-player1 { background-color: #b7d5f2; }
    .word-owned-player2 { background-color: #f6c28b; }
    #player1Score, #player2Score {
      width: 160px;
      min-height: 300px;
      padding: 10px;
      font-size: 20px;
      font-weight: bold;
      border: 2px solid #333;
    }
    #player1Score { background-color:  #b7d5f2; }
    #player2Score { background-color: #f6c28b; }
    #currentTurn {
      font-size: 20px;
      margin: 10px;
      color: #056762;
    }
    #game {
      display: grid;
      grid-template-columns: repeat(12, 50px);
      grid-gap: 5px;
      padding: 10px;
      border: 2px solid #333;
      background-color: #eee;
    }
    .hidden {
      display: none;
    }
  </style>
</head>
<body>

<h1 id="game-title">ê²Œì„ ì œëª©</h1>
<p id="game-desc">ê²Œì„ ì„¤ëª…</p>

<div class="game-container">

  <div class="player-name-row">
    <div class="player-input"><input type="text" id="player1Name" placeholder="first player" /></div>
    <div class="player-input"><input type="text" id="player2Name" placeholder="second player" /></div>
  </div>

  <div class="start-section">
    <button id="startBtn" class="game-button">START GAME</button>
  </div>

  <div id="gameSection" class="hidden">
    <div id="currentTurn"></div>

```
<div class="guess-section">
  <input type="text" id="guessInput" placeholder="your guess" />
  <button id="guessBtn" class="game-button">SUBMIT</button>
</div>

<div id="wrongGuesses" style="display: none;">
  <strong>Invalid words:</strong> <span id="wrongList"></span>
</div>

<div class="game-area">
  <div id="player1Score"></div>
  <div id="game"></div>
  <div id="player2Score"></div>
</div>

<div class="controls">
  <button id="retryBtn" class="game-button">RETRY</button>
  <button onclick="location.href='index.html'" class="game-button">HOME</button>
</div>
```

  </div>

</div>

<script>
window.onload = () => {
  const urlParams = new URLSearchParams(window.location.search);
  const poolFile = urlParams.get('pool');
  if (!poolFile) {
    document.body.innerHTML = '<p>âŒ ì›Œë“œí’€ íŒŒì¼ì´ ì§€ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.</p>';
    return;
  }

  fetch('wordpools/' + poolFile + '.json')
    .then(res => res.json())
    .then(data => {
      document.getElementById('game-title').textContent = data.title || 'ê²Œì„ ì œëª©';
      document.getElementById('game-desc').textContent = data.description || 'ê²Œì„ ì„¤ëª…';
      words = [];
      for (let length in data.words) {
        const count = data.wordCount[length] || 0;
        words.push(...getRandomSample(data.words[length], count));
      }
      console.log('ì´ ë‹¨ì–´ ìˆ˜:', words.length);
      console.log('ë‹¨ì–´ ëª©ë¡:', words);
    })
    .catch(err => {
      document.body.innerHTML = '<p>âŒ ì›Œë“œí’€ ë¡œë”© ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + err.message + '</p>';
    });

  const gridSize = 12;
  const totalCells = gridSize * gridSize;
  let board, revealed, wordMap, foundWords, currentPlayer, foundBy, words, usedIndexes;
  let clovers = new Set(), daisies = new Set(), resultShown = false, gameStarted = false;
  let player1 = "í”Œë ˆì´ì–´1", player2 = "í”Œë ˆì´ì–´2", currentPlayerName = "", wrongGuesses = [];

  const gameEl = document.getElementById('game');
  const player1ScoreEl = document.getElementById('player1Score');
  const player2ScoreEl = document.getElementById('player2Score');
  const retryBtn = document.getElementById('retryBtn');
  const startBtn = document.getElementById('startBtn');
  const gameSection = document.getElementById('gameSection');
  const currentTurnEl = document.getElementById('currentTurn');
  const guessInput = document.getElementById('guessInput');
  const guessBtn = document.getElementById('guessBtn');
  const wrongListEl = document.getElementById('wrongList');
  const wrongGuessesEl = document.getElementById('wrongGuesses');

  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  function getRandomSample(arr, count) {
    if (count >= arr.length) return [...arr];
    const shuffled = [...arr];
    shuffle(shuffled);
    return shuffled.slice(0, count);
  }

  function startGame() {
    player1 = document.getElementById('player1Name').value.trim() || "í”Œë ˆì´ì–´1";
    player2 = document.getElementById('player2Name').value.trim() || "í”Œë ˆì´ì–´2";
    
    gameSection.classList.remove('hidden');
    startBtn.style.display = 'none';
    gameStarted = true;
    
    init();
  }

  function init() {
    board = Array(totalCells).fill(null);
    revealed = Array(totalCells).fill(false);
    wordMap = {};
    foundWords = new Set();
    foundBy = { player1: [], player2: [] };
    currentPlayer = 'player1';
    usedIndexes = new Set();
    clovers.clear();
    daisies.clear();
    wrongGuesses = [];
    wrongListEl.textContent = "";
    wrongGuessesEl.style.display = 'none';
    resultShown = false;

    gameEl.innerHTML = '';
    for (let i = 0; i < totalCells; i++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.onclick = () => { if (!resultShown) handleClick(i); };
      gameEl.appendChild(cell);
    }

    // ë‹¨ì–´ ë°°ì¹˜ (ì¬ì‹œë„ ë¡œì§ ê°•í™”)
    let placedWords = [];
    shuffle(words);
    
    for (let word of words) {
      let placed = false;
      for (let attempt = 0; attempt < 500; attempt++) {
        if (placeWord(word)) {
          placedWords.push(word);
          placed = true;
          break;
        }
      }
      if (!placed) {
        console.log('ë°°ì¹˜ ì‹¤íŒ¨í•œ ë‹¨ì–´:', word);
      }
    }
    
    console.log('ì‹¤ì œ ë°°ì¹˜ëœ ë‹¨ì–´ ìˆ˜:', placedWords.length);
    console.log('ë°°ì¹˜ëœ ë‹¨ì–´ë“¤:', placedWords);
    
    // í´ë¡œë²„/ë°ì´ì§€ ë°°ì¹˜ (ë‹¨ì–´ ì˜ì—­ í”¼í•˜ê¸°)
    placeDaisies(2);
    placeClovers(5);
    fillEmptyCells();
    updateScore();
    updateTurnDisplay();
    
    // ê²Œì„ ì¢…ë£Œ ì¡°ê±´ í™•ì¸
    checkGameEnd();
  }

  function canPlaceWord(word, x, y, dx, dy) {
    for (let i = 0; i < word.length; i++) {
      let nx = x + dx * i, ny = y + dy * i;
      if (nx < 0 || ny < 0 || nx >= gridSize || ny >= gridSize) return false;
      
      let idx = ny * gridSize + nx;
      if (board[idx] && board[idx] !== word[i]) return false;
      if (usedIndexes.has(idx)) return false;
    }
    return true;
  }

  function placeWord(word) {
    const directions = [
      { x: 1, y: 0 },   // ê°€ë¡œ
      { x: 0, y: 1 },   // ì„¸ë¡œ
      { x: 1, y: 1 },   // ëŒ€ê°ì„  \
      { x: 1, y: -1 }   // ëŒ€ê°ì„  /
    ];
    
    for (let dir of directions) {
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          if (canPlaceWord(word, x, y, dir.x, dir.y)) {
            let positions = [];
            for (let i = 0; i < word.length; i++) {
              let nx = x + dir.x * i, ny = y + dir.y * i, idx = ny * gridSize + nx;
              board[idx] = word[i];
              usedIndexes.add(idx);
              positions.push(idx);
            }
            wordMap[word] = positions;
            return true;
          }
        }
      }
    }
    return false;
  }

  function placeClovers(count) {
    let placed = 0;
    let attempts = 0;
    while (placed < count && attempts < 1000) {
      const idx = Math.floor(Math.random() * totalCells);
      if (!usedIndexes.has(idx) && !clovers.has(idx) && !daisies.has(idx)) {
        // ì£¼ë³€ì— ë‹¨ì–´ê°€ ì—†ê³  ë‹¤ë¥¸ íŠ¹ìˆ˜ ì•„ì´í…œê³¼ ê±°ë¦¬ê°€ ìˆëŠ”ì§€ í™•ì¸
        if (isSafeForSpecial(idx) && !isNearSpecialItem(idx)) {
          clovers.add(idx);
          placed++;
        }
      }
      attempts++;
    }
    console.log('ë°°ì¹˜ëœ í´ë¡œë²„ ìˆ˜:', clovers.size);
  }

  function placeDaisies(count) {
    let placed = 0;
    let attempts = 0;
    while (placed < count && attempts < 1000) {
      const idx = Math.floor(Math.random() * totalCells);
      if (!usedIndexes.has(idx) && !clovers.has(idx) && !daisies.has(idx)) {
        // ì£¼ë³€ì— ë‹¨ì–´ê°€ ì—†ê³  ë‹¤ë¥¸ íŠ¹ìˆ˜ ì•„ì´í…œê³¼ ê±°ë¦¬ê°€ ìˆëŠ”ì§€ í™•ì¸
        if (isSafeForSpecial(idx) && !isNearSpecialItem(idx)) {
          daisies.add(idx);
          placed++;
        }
      }
      attempts++;
    }
    console.log('ë°°ì¹˜ëœ ë°ì´ì§€ ìˆ˜:', daisies.size);
  }

  function isNearSpecialItem(idx) {
    const x = idx % gridSize;
    const y = Math.floor(idx / gridSize);
    
    // ì£¼ë³€ 2ì¹¸ ë°˜ê²½ ë‚´ì— ë‹¤ë¥¸ íŠ¹ìˆ˜ ì•„ì´í…œì´ ìˆëŠ”ì§€ í™•ì¸
    for (let dy = -2; dy <= 2; dy++) {
      for (let dx = -2; dx <= 2; dx++) {
        if (dx === 0 && dy === 0) continue;
        const nx = x + dx;
        const ny = y + dy;
        if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
          const nIdx = ny * gridSize + nx;
          if (clovers.has(nIdx) || daisies.has(nIdx)) {
            return true;
          }
        }
      }
    }
    return false;
  }

  function isSafeForSpecial(idx) {
    const x = idx % gridSize;
    const y = Math.floor(idx / gridSize);
    
    // ì£¼ë³€ 8ì¹¸ í™•ì¸
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        const nx = x + dx;
        const ny = y + dy;
        if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
          const nIdx = ny * gridSize + nx;
          if (usedIndexes.has(nIdx)) return false;
        }
      }
    }
    return true;
  }

  function fillEmptyCells() {
    const filler = 'ê°™ê°›ê°œê±°ê±´ê±¸ê²ƒê²Œê³ ê´´êµêµ­ê¶ê·¸ê·¼ê¸ˆê¸°ê¸´ê¹Œê¹œê¹¨êº¾ê»´ê¼¼ê½ê¾¸ë”ë‚œë‚´ë„˜ë„£ë„¤ë†€ë†ˆëˆ„ë‰´ëŠ”ë‹ˆë‹˜ë‹¤ë‹¥ëŒ€ëŒ„ë”ë˜ë©ë°ë„ë™ë‘ë“œë“ë“ ë“£ë“¤ë“±ë””ë”œë”±ë•Œë•¡ë˜‘ëš«ë›°ë¼ë½ë€ëŒëë‘ë˜ëœëŸ¬ë ˆë ¤ë ¥ë ¸ë¡œë¡­ë¥´ë¥¸ë¥¼ë¦¬ë¦°ë¦¼ë§ˆë§Œë§›ë§ë§¨ë¨¸ë¨¼ë©€ë©”ë©˜ë©°ëª°ë¬´ë¬»ë­˜ë¯¸ë¯¼ë°”ë°›ë°©ë²„ë²…ë²ˆë´ë´¤ë¶€ë¶™ë¸Œë¸”ë¹„ë¹ˆë¹Œë¹”ë¹ ë¹¡ë¹¨ë¹¼ë»¥ì‚¬ìƒˆìƒì„œì„­ì„°ì„¸ìˆ™ì‰¬ìŠ´ì‹¤ì‹¶ìŒì“°ì”Œì”»ì•„ì•…ì•Œì•˜ì• ì•¼ì–´ì—„ì—…ì—†ì—ˆì—‰ì—ì—¬ì—´ì˜›ì˜¤ì˜¨ì˜¬ì™€ì™”ì™œìš°ìš¸ì›ìœ„ìœ ìœ¤ìœ¼ì„ìŒì˜ìµì¸ìƒìˆìŠì‘ì–ì˜ì €ì „ì œì ¸ì¢‹ì£¼ì¤¬ì§œì§ì°ì°¨ì°©ì°¸ì°½ì±„ì²™ì²œì²­ì²´ì³¤ì´ˆì¶œì·„ì·¨ì¹˜ì¹œì¹´ì¼œì½”ì½œí¬í…Œí† íŠ¸íŠ¼í­í•€í•˜í•™í•œí• í•´í–„í–ˆí–‰í˜„í˜¸í˜¼í™”í™˜íˆ'.split('');
    shuffle(filler);
    let i = 0;
    for (let j = 0; j < totalCells; j++) {
      if (!board[j] && !clovers.has(j) && !daisies.has(j)) {
        board[j] = filler[i++ % filler.length];
      }
    }
  }

  function reveal(index) {
    if (revealed[index]) return;
    revealed[index] = true;
    const cell = gameEl.children[index];
    
    if (clovers.has(index)) {
      cell.textContent = 'ğŸ€';
      // ìƒí•˜ì¢Œìš° 4ì¹¸ ì—´ê¸°
      const directions = [-gridSize, gridSize, -1, 1];
      for (let d of directions) {
        const newIdx = index + d;
        if (newIdx >= 0 && newIdx < totalCells) {
          // ì¢Œìš° ì´ë™ ì‹œ ê°™ì€ í–‰ì— ìˆëŠ”ì§€ í™•ì¸
          if (d === -1 || d === 1) {
            if (Math.floor(index / gridSize) === Math.floor(newIdx / gridSize)) {
              reveal(newIdx);
            }
          } else {
            reveal(newIdx);
          }
        }
      }
    } else if (daisies.has(index)) {
      cell.textContent = 'ğŸŒ¼';
      // ì£¼ë³€ 8ì¹¸ ëª¨ë‘ ì—´ê¸°
      const x = index % gridSize;
      const y = Math.floor(index / gridSize);
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
            const nIdx = ny * gridSize + nx;
            if (!revealed[nIdx]) reveal(nIdx);
          }
        }
      }
    } else {
      cell.textContent = board[index];
    }
    cell.classList.add('revealed');
  }

  function updateScore() {
    player1ScoreEl.innerHTML = `<strong>${player1}</strong><br><br>` + foundBy.player1.map(w => `âœ“ ${w}`).join("<br>");
    player2ScoreEl.innerHTML = `<strong>${player2}</strong><br><br>` + foundBy.player2.map(w => `âœ“ ${w}`).join("<br>");
  }

  function updateTurnDisplay() {
    if (!gameStarted) return;
    currentPlayerName = currentPlayer === 'player1' ? player1 : player2;
    currentTurnEl.textContent = `${currentPlayerName}ë‹˜ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤`;
  }

  function switchTurn(extra) {
    if (!extra) {
      currentPlayer = currentPlayer === 'player1' ? 'player2' : 'player1';
    }
    updateTurnDisplay();
  }

  function handleClick(index) {
    if (revealed[index] || resultShown || !gameStarted) return;
    
    const extra = clovers.has(index) || daisies.has(index);
    reveal(index);
    checkWords();
    checkGameEnd();
    
    if (!resultShown) {
      switchTurn(extra);
    }
  }

  function checkWords() {
    for (let word of Object.keys(wordMap)) {
      if (foundWords.has(word)) continue;
      const pos = wordMap[word];
      if (pos.every(i => revealed[i])) {
        foundWords.add(word);
        foundBy[currentPlayer].push(word);
        pos.forEach(i => {
          const cell = gameEl.children[i];
          cell.classList.add(currentPlayer === 'player1' ? 'word-owned-player1' : 'word-owned-player2');
        });
        updateScore();
      }
    }
  }

  function checkGameEnd() {
    const totalWords = Object.keys(wordMap).length;
    if (foundWords.size >= totalWords && totalWords > 0) {
      resultShown = true;
      const p1Count = foundBy.player1.length;
      const p2Count = foundBy.player2.length;
      
      let winner;
      if (p1Count > p2Count) winner = player1;
      else if (p2Count > p1Count) winner = player2;
      else winner = "ë¬´ìŠ¹ë¶€";
      
      setTimeout(() => {
        alert(`ê²Œì„ ì¢…ë£Œ!\n${winner === "ë¬´ìŠ¹ë¶€" ? "ë¬´ìŠ¹ë¶€ì…ë‹ˆë‹¤!" : winner + "ë‹˜ì´ ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤!"}\n\n${player1}: ${p1Count}ê°œ\n${player2}: ${p2Count}ê°œ`);
      }, 500);
    }
  }

  function handleGuess() {
    if (!gameStarted) return;
    
    const guess = guessInput.value.trim().toUpperCase(); // ëŒ€ë¬¸ìë¡œ ë³€í™˜
    guessInput.value = "";
    if (!guess || foundWords.has(guess)) return;
    
    if (wordMap[guess]) {
      const pos = wordMap[guess];
      pos.forEach(i => {
        if (!revealed[i]) reveal(i);
      });
      foundWords.add(guess);
      foundBy[currentPlayer].push(guess);
      pos.forEach(i => {
        const cell = gameEl.children[i];
        cell.classList.add(currentPlayer === 'player1' ? 'word-owned-player1' : 'word-owned-player2');
      });
      updateScore();
      checkGameEnd();
    } else {
      if (!wrongGuesses.includes(guess)) {
        wrongGuesses.push(guess);
        wrongListEl.textContent = wrongGuesses.join(", ");
        wrongGuessesEl.style.display = 'block';
      }
    }
    
    if (!resultShown) {
      switchTurn(false);
    }
  }

  function retry() {
    if (!gameStarted) return;
    init();
  }

  startBtn.onclick = startGame;
  retryBtn.onclick = retry;
  guessBtn.onclick = handleGuess;
  guessInput.addEventListener('keypress', e => {
    if (e.key === 'Enter') handleGuess();
  });
};
</script>

</body>
</html>
